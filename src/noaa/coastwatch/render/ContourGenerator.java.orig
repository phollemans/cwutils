////////////////////////////////////////////////////////////////////////
/*
     FILE: ContourGenerator.java
  PURPOSE: Generates contour lines based on gridded data.
   AUTHOR: Peter Hollemans
     DATE: 2003/12/10
  CHANGES: n/a

  CoastWatch Software Library and Utilities
  Copyright 2003, USDOC/NOAA/NESDIS CoastWatch

*/
////////////////////////////////////////////////////////////////////////

// Package
// -------
package noaa.coastwatch.render;

// Imports
// -------
import java.util.*;
import java.io.*;
import noaa.coastwatch.util.*;

/**
 * A contour generator creates lists of Earth data points that follow
 * lines of constant value in a gridded dataset.  A contour generator
 * may be used, for example, to create bathymetry or topographic
 * contours from digital elevation model data, or to create contour
 * lines from data in any 2D dataset.
 */
public class ContourGenerator
  extends EarthVectorSource {

  // Constants
  // ---------
  
  /** The grid data location offsets for triangles. */
  private static final double[][] OFFSETS = new double[][] {
    {0,1,1,0,0.5},
    {0,0,1,1,0.5}
  };

  /** The case table for triangle/contour intersections. */
  private static final int[][][] CASE_TABLE = new int[][][] {
    {{0,0,8}, {0,2,5}, {7,6,9}},
    {{0,3,4}, {1,3,1}, {4,3,0}},
    {{9,6,7}, {5,2,0}, {8,0,0}}
  };

  /** The location increment table for triangle sides. */
  private static final double[][][] LOCATION_SIDES = new double[][][] {
    {{0,1,0.5}, {1,1,0.5}, {1,0,0.5}, {0,0,0.5}},
    {{0,0,0.5}, {0,1,0.5}, {1,1,0.5}, {1,0,0.5}}
  };

  /** The location increment table for triangle side offsets. */
  private static double[][][] LOCATION_OFFSETS = new double[][][] {
    {{1,-0.5,-0.5}, {0,-0.5,0.5}, {-1,0.5,0.5}, {0,0.5,-0.5}},
    {{0,0.5,-0.5}, {1,-0.5,-0.5}, {0,-0.5,0.5}, {-1,0.5,0.5}}
  };

  // Variables
  // ---------

  /** The grid data for contouring. */
  private Grid grid;

  /** The Earth transform for the grid data. */
  private EarthTransform trans;

  /** The contour levels to generate. */
  private double[] levels;

  /** The starting data location for contouring. */
  private DataLocation start;

  /** The ending data location for contouring. */
  private DataLocation end;

  /** The number of data rows. */
  private int rows;

  /** The number of data columns. */
  private int cols;

  /** The maximum index at each level. */
  private int[] levelMaxIndex;

  ////////////////////////////////////////////////////////////

  /** 
   * Creates a new contour generator based on data in the grid.
   * Initially, no contours are available until a call to
   * <code>select()</code> is made.
   *
   * @param grid the grid data for contouring.
   * @param trans the Earth transform for the grid.   
   * @param levels the contour levels to generate.
   */
  public ContourGenerator (
    Grid grid,
    EarthTransform trans,
    double[] levels
  ) {

    this.grid = grid;
    this.trans = trans;
    this.levels = (double[]) levels.clone();
    Arrays.sort (this.levels);
    this.levelMaxIndex = new int[levels.length];

  } // ContourGenerator constructor

  ////////////////////////////////////////////////////////////

  protected void select () throws IOException {

    // Set data bounds
    // ---------------
    int[] extremes = area.getExtremes();


    System.out.println ("got extremes = " + 
                        extremes[0] + "," +
                        extremes[1] + "," +
                        extremes[2] + "," +
                        extremes[3]);




    DataLocation northWest = trans.transform (new EarthLocation (extremes[0], 
      extremes[3]));
    DataLocation southEast = trans.transform (new EarthLocation (extremes[1], 
      extremes[2]));



    System.out.println ("got northWest = " + northWest);
    System.out.println ("got southEast = " + southEast);



    int[] dims = grid.getDimensions();
    start = new DataLocation (
      Math.floor (Math.min (northWest.get(0), southEast.get(0))),
      Math.floor (Math.min (northWest.get(1), southEast.get(1)))
    ).truncate (dims);
    end = new DataLocation (
      Math.ceil (Math.max (northWest.get(0), southEast.get(0))),
      Math.ceil (Math.max (northWest.get(1), southEast.get(1)))
    ).truncate (dims);



    System.out.println ("got start = " + start);
    System.out.println ("got end = " + end);



    // Set data dimensions
    // -------------------
    rows = (int) Math.round (end.get (Grid.ROWS) - start.get (Grid.ROWS));
    cols = (int) Math.round (end.get (Grid.COLS) - start.get (Grid.COLS));

    // Create new contour vectors
    // --------------------------
    Contour[] contours = getContours();
    vectorList = new Vector();
    for (int i = 0; i < levels.length; i++) {
      Vector contourData = contours[i].getContour();


      System.out.println ("got " + contourData.size() + " vectors at level = " + levels[i]);
      if (contourData.size() > 0)
        System.out.println ("vector 0 size = " + ((Vector)contourData.get(0)).size());



      if (i == 0) levelMaxIndex[i] = contourData.size() - 1;
      else levelMaxIndex[i] = levelMaxIndex[i] + contourData.size();
      vectorList.addAll (contourData);
    } // for

  } // select

  ////////////////////////////////////////////////////////////

  /** 
   * Gets the contour level of the Earth vector at the specified
   * index. 
   */
  public double getLevel (
    int index
  ) {

    for (int i = 0; i < levels.length; i++)
      if (index <= levelMaxIndex[i]) return (levels[i]);
    return (Double.NaN);

  } // getLevel

  ////////////////////////////////////////////////////////////

  /** 
   * Gets a location hash code.  The code is based on an approximate
   * location, rounded to the nearest tenth of a unit.  Generally it
   * is expected that contour lines on the same level whose endpoints
   * are closer than 1/10 of a unit apart are supposed to be joined at
   * those endpoints.
   * 
   * @param loc the location to hash.  The location must be in range of
   * the start and end contouring coordinates.
   *
   * @return the location hash code.
   */
  private int getLocationHash (
    DataLocation loc
  ) {

    int row = (int) Math.round ((loc.get (Grid.ROWS) - 
      start.get (Grid.ROWS)) * 10);
    int col = (int) Math.round ((loc.get (Grid.COLS) - 
      start.get (Grid.COLS)) * 10);
    int hash = row*(cols*10) + col;
    return (hash);

  } // getLocationHash

  ////////////////////////////////////////////////////////////

  /**
   * A triangle is one of many in a dataset of gridded data in which
   * each data square has been broken up into four triangles.  For 
   * example:
   *
   *    o-------------------o  
   *    | \       3       / |
   *    |   \           /   |
   *    |     \       /     |
   *    |       \   /       |     Each triangle has an index in [0..3],
   *    | 0       o       2 |     counter-clockwise order.
   *    |       /   \       |
   *    |     /       \     |
   *    |   /           \   |
   *    | /       1       \ |
   *    o-------------------o  
   */
  private class Triangle {

    // Variables
    // ---------

    /** The triangle grid row. */
    private int row;

    /** The triangle grid column. */
    private int col;

    /** The triangle index. */
    private int index;

    ////////////////////////////////////////////////////////

    /**
     * Creates a new triangle.
     *
     * @param row the triangle row within the grid.
     * @param col the triangle column within the grid.
     * @param index the triangle index within the grid square.
     */
    public Triangle (
      int row,
      int col,
      int index
    ) {

      this.row = row;
      this.col = col;
      this.index = index;

    } // Triangle constructor 

    ////////////////////////////////////////////////////////

    /**
     * Gets the data location of a point along the triangle side.
     *
     * @param side the triangle side in the range [0..2].
     * @param offset the offset along the side in the range [0..1].
     *
     * @return the data location of the specified point.
     */
    public DataLocation getLocation (
      int side,
      double offset
    ) {

      double row = this.row + LOCATION_SIDES[Grid.ROWS][index][side] + 
        LOCATION_OFFSETS[Grid.ROWS][index][side]*offset;
      double col = this.col + LOCATION_SIDES[Grid.COLS][index][side] + 
        LOCATION_OFFSETS[Grid.COLS][index][side]*offset;
      return (new DataLocation (row, col));

    } // getLocation

    ////////////////////////////////////////////////////////
    
  } // Triangle class

  ////////////////////////////////////////////////////////////

  /**
   * A contour segment represents a section of a data contour line
   * that is confined to a triangle in the triangular mesh.  A contour
   * segment can supply a unique hash code for its starting and ending
   * points.
   */ 
  private class ContourSegment {

    // Variables
    // ---------

    /** The segment start location. */
    private DataLocation start;

    /** The segment end location. */
    private DataLocation end;

    /** The segment start hash code. */
    private int startHash;

    /** The segment end hash code. */
    private int endHash;

    ////////////////////////////////////////////////////////

    /**
     * Creates a new contour segment.
     *
     * @param tri the contour segment triangle.
     * @param startSide the segment starting side in the range [0..2].
     * @param endSide the segment ending side in the range [0..2].
     * @param startOffset the segment starting offset in the range [0..1].
     * @param endOffset the segment ending offset in the range [0..1].
     */
    public ContourSegment (
      Triangle tri,
      int startSide,
      int endSide,
      double startOffset,
      double endOffset      
    ) {

      // Initialize
      // ----------
      start = tri.getLocation (startSide, startOffset);
      end = tri.getLocation (endSide, endOffset);

      // Create hash codes
      // -----------------
      startHash = getLocationHash (start);
      endHash = getLocationHash (end);

    } // ContourSegment constructor

    ////////////////////////////////////////////////////////

    public String toString () {

      return ("ContourSegment[" +
        "start=" + start + "," + 
        "end=" + end + "," +
        "startHash=" + startHash + "," +
        "endHash=" + endHash + "]");

    } // toString

    ////////////////////////////////////////////////////////

    /** Gets the segment start location. */
    public DataLocation getStart () { return (start); }

    ////////////////////////////////////////////////////////

    /** Gets the segment end location. */
    public DataLocation getEnd () { return (end); }

    ////////////////////////////////////////////////////////

    /** Gets the segment start location hash code. */
    public int getStartHash () { return (startHash); }

    ////////////////////////////////////////////////////////

    /** Gets the segment end location hash code. */
    public int getEndHash () { return (endHash); }

    ////////////////////////////////////////////////////////

  } // ContourSegment class

  ////////////////////////////////////////////////////////////

  /**
   * A contour line stores a number of contour data locations from one
   * contour level.  A contour line has a unique start and end hash
   * key.
   */
  private class ContourLine {

    // Variables
    // ---------

    /** The contour line data locations. */
    private LinkedList locations;

    /** The segment start hash code. */
    private int startHash;

    /** The segment end hash code. */
    private int endHash;
    
    ////////////////////////////////////////////////////////

    /** Creates a new empty contour line. */
    public ContourLine () {

      locations = new LinkedList();

    } // ContourLine constructor

    ////////////////////////////////////////////////////////

    /** Gets the line start location hash code. */
    public int getStartHash () { return (startHash); }

    ////////////////////////////////////////////////////////

    /** Gets the line end location hash code. */
    public int getEndHash () { return (endHash); }

    ////////////////////////////////////////////////////////

    /** Gets the list of data locations. */
    public List getLocations () { return (locations); }

    ////////////////////////////////////////////////////////

    public String toString () { 

      return ("ContourLine[" +
        "locations=" + locations + "," +
        "startHash=" + startHash + "," +
        "endHash=" + endHash + "]");

    } // toString

    ////////////////////////////////////////////////////////

    /** 
     * Adds a new segment to the line.
     *
     * @param segment the new segment to add.  In order for the
     * operation to be successful, the new segment must have an 
     * endpoint in common with this line, or the line must be empty.
     */
    public void addSegment (
      ContourSegment segment
    ) {

      // Insert into empty line
      // ----------------------
      if (locations.size() == 0) {
        locations.add (segment.getStart());
        locations.add (segment.getEnd());
        startHash = segment.getStartHash();
        endHash = segment.getEndHash();
      } // if

      // Insert on one end of line
      // -------------------------
      else {
        int segmentStart = segment.getStartHash();
        int segmentEnd = segment.getEndHash();
        if (segmentStart == startHash) {
          locations.addFirst (segment.getEnd());
          startHash = segmentEnd;          
        } // if
        else if (segmentStart == endHash) {
          locations.addLast (segment.getEnd());
          endHash = segmentEnd;
        } // else if 
        else if (segmentEnd == startHash) {
          locations.addFirst (segment.getStart());
          startHash = segmentStart;
        } // else if
        else if (segmentEnd == endHash) {
          locations.addLast (segment.getStart());
          endHash = segmentStart;
        } // else if
      } // else

    } // addSegment

    ////////////////////////////////////////////////////////

    /** 
     * Adds another contour line to this one.
     *
     * @param line the contour line to add.  In order for the
     * operation to be successful, the contour line must have an 
     * endpoint in common with this line.
     */
    public void addLine (
      ContourLine line
    ) {

      // Check for empty line
      // --------------------
      if (line.locations.size() == 0) return;
      if (locations.size() == 0) {
        locations = line.locations;
        startHash = line.startHash;
        endHash = line.endHash;
      } // if 

      // Add other locations
      // -------------------
      else {
        int lineStart = line.getStartHash();
        int lineEnd = line.getEndHash();
        LinkedList lineLocations = (LinkedList) line.locations.clone();
        if (lineStart == startHash) {
          Collections.reverse (lineLocations);
          lineLocations.removeLast();
          lineLocations.addAll (locations);
          locations = lineLocations;
          startHash = lineEnd;
        } // if
        else if (lineStart == endHash) {
          lineLocations.removeFirst();
          locations.addAll (lineLocations);
          endHash = lineEnd;
        } // else if
        else if (lineEnd == startHash) {
          lineLocations.removeLast();
          lineLocations.addAll (locations);
          locations = lineLocations;
          startHash = lineStart;
        } // else if
        else if (lineEnd == endHash) {
          Collections.reverse (lineLocations);
          lineLocations.removeFirst();
          locations.addAll (lineLocations);
          endHash = lineStart;
        } // else if
      } // else

    } // addLine

    ////////////////////////////////////////////////////////

  } // ContourLine class

  ////////////////////////////////////////////////////////////

  /**
   * A contour stores a number of contour segments from one contour
   * level as a set of continuous lines.
   */
  private class Contour {

    // Variables
    // ---------

    /** The map of contours, hashed by start location. */
    private HashMap startMap;

    /** The map of contours, hashed by end location. */
    private HashMap endMap;

    /** The contour level. */
    private double level;

    ////////////////////////////////////////////////////////

    /**
     * Creates a new contour.
     *
     * @param level the contour level.
     */
    public Contour (
      double level
    ) {

      this.level = level;
      startMap = new HashMap();
      endMap = new HashMap();

    } // Contour

    ////////////////////////////////////////////////////////

    /**
     * Adds a segment to the existing contour.  The segment must be
     * from the same contour level, otherwise an inconsistency may
     * arise in joining the new segment with the existing segments.
     *
     * @param segment the new segment to add.
     */
    public void addSegment (
      ContourSegment segment
    ) {

      // Get existing contour line
      // -------------------------
      ContourLine line = null;
      HashMap[] maps = new HashMap[] {startMap, endMap};
      Integer[] keys = new Integer[] {
        new Integer (segment.getStartHash()),
        new Integer (segment.getEndHash())
      };
      int mapIndex = 0, keyIndex = 0;
      for (mapIndex = 0; mapIndex < 2; mapIndex++) {
        for (keyIndex = 0; keyIndex < 2; keyIndex++) {
          if (maps[mapIndex].containsKey (keys[keyIndex])) {
            line = (ContourLine) maps[mapIndex].get (keys[keyIndex]);
            break;
          } // if
        } // for
        if (line != null) break;
      } // for

      // Create new contour line
      // -----------------------
      if (line == null) {



        System.out.println ("creating new contour line");




        line = new ContourLine();
        line.addSegment (segment);
        startMap.put (new Integer (line.getStartHash()), line);
        endMap.put (new Integer (line.getEndHash()), line);
      } // if





      // Add segment to contour line
      // ---------------------------
      else {



        System.out.println ("adding segment to contour line");



        line.addSegment (segment);
        maps[mapIndex].remove (keys[keyIndex]);

        // Join start-to-start or end-to-end
        // ---------------------------------
        Integer[] lineKeys = new Integer[] {
          new Integer (line.getStartHash()),
          new Integer (line.getEndHash())
        };
        if (maps[mapIndex].containsKey (lineKeys[mapIndex])) {
          maps[1-mapIndex].remove (lineKeys[1-mapIndex]);
          ContourLine existingLine = (ContourLine) maps[mapIndex].remove (
            lineKeys[mapIndex]);
          Integer[] existingLineKeys = new Integer[] {
            new Integer (existingLine.getStartHash()), 
            new Integer (existingLine.getEndHash())
          };
          maps[1-mapIndex].remove (existingLineKeys[1-mapIndex]);
          line.addLine (existingLine);
          startMap.put (new Integer (line.getStartHash()), line);
          endMap.put (new Integer (line.getEndHash()), line);
        } // if

        // Join start-to-end
        // -----------------
        else if (maps[1-mapIndex].containsKey (lineKeys[mapIndex])) {


          System.err.println ("start-to-end line join found, line = " +
                              maps[1-mapIndex].get (lineKeys[mapIndex]));


          maps[1-mapIndex].remove (lineKeys[1-mapIndex]);


          System.err.println ("(after remove) line = " +
                              maps[1-mapIndex].get (lineKeys[mapIndex]));


          ContourLine existingLine = (ContourLine) maps[1-mapIndex].remove (
            lineKeys[mapIndex]);
          Integer[] existingLineKeys = new Integer[] {
            new Integer (existingLine.getStartHash()), 
            new Integer (existingLine.getEndHash())
          };
          maps[mapIndex].remove (existingLineKeys[mapIndex]);
          line.addLine (existingLine);
          startMap.put (new Integer (line.getStartHash()), line);
          endMap.put (new Integer (line.getEndHash()), line);
        } // else if

        // Insert back into map
        // --------------------
        else maps[mapIndex].put (lineKeys[mapIndex], line);

      } // else

    } // addSegment

    ////////////////////////////////////////////////////////

    /** 
     * Gets the contour as a list of Earth vector objects.
     */
    public Vector getContour () {

      // Create return vector
      // --------------------
      Vector list = new Vector();
      
      // Loop over each set of data locations
      // ------------------------------------
      for (Iterator iter = startMap.values().iterator(); iter.hasNext();) {
        List locations = ((ContourLine) iter.next()).getLocations();

        // Create Earth vector
        // -------------------
        EarthVector vector = new EarthVector();
        for (Iterator locIter = locations.iterator(); locIter.hasNext();) {
          EarthLocation loc = trans.transform ((DataLocation) locIter.next());
          vector.add (loc);
        } // for
        list.add (vector);

      } // for

      return (list);

    } // getContour

    ////////////////////////////////////////////////////////

  } // Contour class

  ////////////////////////////////////////////////////////////

  /**
   * Gets the set of contours based on grid data.
   * 
   * @return the array of contours.
   */
  private Contour[] getContours () {

    // Create contours
    // ---------------
    int nlevels = levels.length;
    Contour[] contours = new Contour[nlevels];
    for (int i = 0; i < nlevels; i++)
      contours[i] = new Contour (i);

    // Initialize coordinates
    // ----------------------
    DataLocation dataStart = (DataLocation) start.clone();
    DataLocation dataEnd = ((DataLocation) end.clone()).translate (-1, -1);
    int[] stride = new int[] {1, 1};
    DataLocation loc = (DataLocation) start.clone();

    // Loop over each grid square
    // --------------------------
    do {



      //      System.out.println ("working on loc = " + loc);



      // Get square index
      // ----------------
      int row = (int) Math.round (loc.get (Grid.ROWS));
      int col = (int) Math.round (loc.get (Grid.COLS));

      // Get values at corners of square and center
      // ------------------------------------------
      /*
       *  0 o-------------------o 3
       *    | \               / |
       *    |   \           /   |     
       *    |     \       /     |     
       *    |       \   /       |     Each data point has an index in the
       *    |         o         |     range [0..4], counter-clockwise order,
       *    |       / 4 \       |     with 4 in the center.
       *    |     /       \     |     
       *    |   /           \   |
       *    | /               \ |
       *  1 o-------------------o 2
       */
      double[] values = new double[5];
      for (int i = 0; i < 4; i++)
        values[i] = grid.getValue (loc.translate (OFFSETS[Grid.ROWS][i], 
          OFFSETS[Grid.COLS][i]));
      values[4] = (values[0] + values[1] + values[2] + values[3]) / 4;

      // Find minimum and maximum values
      // -------------------------------
      double minValue = values[0], maxValue = values[0];
      for (int i = 1; i < 4; i++) {
        if (values[i] < minValue) minValue = values[i];
        if (values[i] > maxValue) maxValue = values[i];
      } // for

      // Check for any contours in square
      // --------------------------------
      if (maxValue < levels[0] || minValue > levels[nlevels-1])
        continue;

      // Loop over each contour level
      // ----------------------------
      for (int level = 0; level < nlevels; level++) {

        // Check for contour level in square
        // ---------------------------------
        if (levels[level] < minValue || levels[level] > maxValue)
          continue;

        // Calculate triangle height differences
        // -------------------------------------
        double[] heights = new double[5];
        int signs[] = new int[5];
        for (int i = 0; i < 5; i++) {
          heights[i] = values[i] - levels[level];
          signs[i] = (heights[i] < 0 ? -1 : heights[i] > 0 ? 1 : 0);
        } // for

        // Loop over each triangle in square
        // ---------------------------------
        for (int index = 0; index < 4; index++) {

          // Initialize triangle
          // -------------------
          Triangle tri = null;

          // Get triangle corner points
          // --------------------------
          int p0 = index;
          int p1 = (index+1)%4;
          int p2 = 4;

          // Calculate contour line coordinates
          // ----------------------------------
          int caseValue = CASE_TABLE[signs[p0]+1][signs[p1]+1][signs[p2]+1];



          if (caseValue == 0) {
            System.out.println ("bad case value=0 at loc=" + loc + ", triangle=" + index);
            for (int i = 0; i < 5; i++)
              System.out.println ("values[" + i + "]=" + values[i]);
            for (int i = 0; i < 5; i++)
              System.out.println ("heights[" + i + "]=" + heights[i]);
          } // if



          if (caseValue != 0) {
            int startSide = 0, endSide = 0;
            double startOffset = 0, endOffset = 0;
            switch (caseValue) {
            case 1: // Line between points 0 and 1
              startSide = 0;
              endSide = 1;
              startOffset = endOffset = 0;
              break;
            case 2: // Line between points 1 and 2
              startSide = 1;
              endSide = 2;
              startOffset = endOffset = 0;
              break;
            case 3: // Line between points 2 and 0
              startSide = 2;
              endSide = 0;
              startOffset = endOffset = 0;
              break;
            case 4: // Line between point 0 and side 1-2
              startSide = 0;
              startOffset = 0;
              endSide = 1;
              endOffset = Math.abs (heights[p1] / (heights[p2] - heights[p1]));
              break;
            case 5: // Line between point 1 and side 2-0
              startSide = 1;
              startOffset = 0;
              endSide = 2;
              endOffset = Math.abs (heights[p2] / (heights[p0] - heights[p2]));
              break;
            case 6: // Line between point 2 and side 0-1
              startSide = 2;
              startOffset = 0;
              endSide = 0;
              endOffset = Math.abs (heights[p0] / (heights[p1] - heights[p0]));
              break;
            case 7: // Line between sides 0-1 and 1-2
              startSide = 0;
              startOffset = 
                Math.abs (heights[p0] / (heights[p1] - heights[p0]));
              endSide = 1;
              endOffset = Math.abs (heights[p1] / (heights[p2] - heights[p1]));
              break;
            case 8: // Line between sides 1-2 and 2-0
              startSide = 1;
              startOffset = 
                Math.abs (heights[p1] / (heights[p2] - heights[p1]));
              endSide = 2;
              endOffset = Math.abs (heights[p2] / (heights[p0] - heights[p2]));
              break;
            case 9: // Line between sides 2-0 and 0-1
              startSide = 2;
              startOffset = 
                Math.abs (heights[p2] / (heights[p0] - heights[p2]));
              endSide = 0;
              endOffset = Math.abs (heights[p0] / (heights[p1] - heights[p0]));
              break;
            default: 
              break;
            } // switch

            // Add segment to contour
            // ----------------------
            if (tri == null) tri = new Triangle (row, col, index);
            ContourSegment segment = new ContourSegment (tri, 
              startSide, endSide, startOffset, endOffset);
            contours[level].addSegment (segment);




            System.out.println ("at row=" + row + ", col=" + col + ", triangle=" + index + ", level=" + level);
            System.out.println ("added segment=" + segment);







          } // if

        } // for

      } // for

    } while (loc.increment (stride, start, end));

    return (contours);
  
  } // getContours

  ////////////////////////////////////////////////////////////

} // ContourGenerator class

////////////////////////////////////////////////////////////////////////
